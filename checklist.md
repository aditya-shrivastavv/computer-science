# Topic Checklist

## - [] 1.Python Primer

- [x] Python Overview
  - [x] The Python Interpreter
  - [x] Preview of a Python Program
- [] Objects in Python
  - [] Identifiers, Objects, and the Assignment Statement
  - [] Creating and Using Objects
  - [] Python’s Built-In Classes
- [] Expressions, Operators, and Precedence
  - [] Compound Expressions and Operator Precedence
- [] Control Flow
  - [] Conditionals
  - [] Loops
- [] Functions
  - [] Information Passing
  - [] Python’s Built-In Functions
- [] Simple Input and Output
  - [] Console Input and Output
  - [] Files
- [] Exception Handling
  - [] Raising an Exception
  - [] Catching an Exception
- [] Iterators and Generators
- [] Additional Python Conveniences
  - [] Conditional Expressions
  - [] Comprehension Syntax
  - [] Packing and Unpacking of Sequences
- [] Scopes and Namespaces
- [] Modules and the Import Statement
  - [] Existing Modules
- [] Exercises

---

## [] 2.Object-Oriented Programming

    [] Goals, Principles, and Patterns
        [] Object-Oriented Design Goals
        [] Object-Oriented Design Principles
        [] Design Patterns
    [] Software Development
        [] Design
        [] Pseudo-Code
        [] Coding Style and Documentation
        [] Testing and Debugging
    [] Class Definitions
        [] Example: CreditCard Class
        [] Operator Overloading and Python’s Special Methods
        [] Example: Multidimensional Vector Class
        [] Iterators
        [] Example: Range Class
    [] Inheritance
        [] Extending the CreditCard Class
        [] Hierarchy of Numeric Progressions
        [] Abstract Base Classes
    [] Namespaces and Object-Orientation
        [] Instance and Class Namespaces
        [] Name Resolution and Dynamic Dispatch
    [] Shallow and Deep Copying
    [] Exercises
---

## [] 3.Algorithm Analysis

    [] Experimental Studies
        [] Moving Beyond Experimental Analysis
    [] The Seven Functions Used in This Book
        [] Comparing Growth Rates
    [] Asymptotic Analysis
        [] The “Big-Oh” Notation
        [] Comparative Analysis
        [] Examples of Algorithm Analysis
    [] Simple Justification Techniques
        [] By Example
        [] The “Contra” Attack
        [] Induction and Loop Invariants
    [] Exercises
---

## [] 4.Recursion

    [] Illustrative Examples
        [] The Factorial Function
        [] Drawing an English Ruler
        [] Binary Sea
        [] File Systems
    [] Analyzing Recursive Algorithms
    [] Recursion Run Amok
        [] Maximum Recursive Depth in Python
    [] Further Examples of Recursion
        [] Linear Recursion
        [] Binary Recursion
        [] Multiple Recursion
    [] Designing Recursive Algorithms
    [] Eliminating Tail Recursion
    [] Exercises
---

## [] 5.Array-Based Sequence

    [] Python’s Sequence Types
    [] Low-Level Arrays
        [] Referential Arrays
        [] Compact Arrays in Python
    [] Dynamic Arrays and Amortization
        [] Implementing a Dynamic Array
        [] Amortized Analysis of Dynamic Arrays
        [] Python’s List Class
    [] Efficiency of Python’s Sequence Types
        [] Python’s List and Tuple Classes
        [] Python’s String Class
    [] Using Array-Based Sequences
        [] Storing High Scores for a Game
        [] Sorting a Sequence
        [] Simple Cryptography
    [] Multidimensional Data Sets
    [] Exercises
---

## [] 6.Stacks, Queues, and Deque

    [] Stacks
        [] The Stack Abstract Data Type
        [] Simple Array-Based Stack Implementation
        [] Reversing Data Using a Stack
        [] Matching Parentheses and HTML Tags
    [] Queues
        [] The Queue Abstract Data Type
        [] Array-Based Queue Implementation
    [] Double-Ended Queues
        [] The Deque Abstract Data Type
        [] Implementing a Deque with a Circular Array
        [] Deques in the Python Collections Module
    [] Exercises
---

## [] 7.Linked List

    [] Singly Linked Lists
        [] Implementing a Stack with a Singly Linked List
        [] Implementing a Queue with a Singly Linked List
    [] Circularly Linked Lists
        [] Round-Robin Schedulers
        [] Implementing a Queue with a Circularly Linked Lis
    [] Doubly Linked Lists
        [] Basic Implementation of a Doubly Linked List
        [] Implementing a Deque with a Doubly Linked Lis
    [] The Positional List ADT
        [] The Positional List Abstract Data Type
        [] Doubly Linked List Implementation
    [] Sorting a Positional List
    [] Case Study: Maintaining Access Frequencies
        [] Using a Sorted List
        [] Using a List with the Move-to-Front Heuristic
    [] Link-Based vsArray-Based Sequences
    [] Exercises
---

## [] 8.Trees

    [] General Trees
        [] Tree Definitions and Properties
        [] The Tree Abstract Data Type
        [] Computing Depth and Height
    [] Binary Trees
        [] The Binary Tree Abstract Data Type
        [] Properties of Binary Trees
    [] Implementing Trees
        [] Linked Structure for Binary Trees
        [] Array-Based Representation of a Binary Tree
        [] Linked Structure for General Trees
    [] Tree Traversal Algorithms
        [] Preorder and Postorder Traversals of General Tree
        [] Breadth-First Tree Traversal
        [] Inorder Traversal of a Binary Tree
        [] Implementing Tree Traversals in Python
        [] Applications of Tree Traversals
        [] Euler Tours and the Template Method Pattern
    [] Case Study: An Expression Tree
    [] Exercises
---

## [] 9.Priority Queue

    [] The Priority Queue Abstract Data Type
        [] Priorities
        [] The Priority Queue ADT
    [] Implementing a Priority Queue
        [] The Composition Design Pattern
        [] Implementation with an Unsorted List
        [] Implementation with a Sorted List
    [] Heaps
        [] The Heap Data Structure
        [] Implementing a Priority Queue with a Heap
        [] Array-Based Representation of a Complete Binary Tre
        [] Python Heap Implementation
        [] Analysis of a Heap-Based Priority Queue
        [] Bottom-Up Heap Construction
        [] Python’s heapq Module
    [] Sorting with a Priority Queue
        [] Selection-Sort and Insertion-Sort
        [] Heap-Sort
    [] Adaptable Priority Queues
        [] Locators
        [] Implementing an Adaptable Priority Queue
    [] Exercises
---

## [] 10.Maps, Hash Tables, and Skip List

    [] Maps and Dictionaries
        [] The Map ADT
        [] Application: Counting Word Frequencies
        [] Python’s MutableMapping Abstract Base Class
        [] Our MapBase Class
        [] Simple Unsorted Map Implementation
    [] Hash Tables
        [] Hash Functions
        [] Collision-Handling Schemes
        [] Load Factors, Rehashing, and Efficiency
        [] Python Hash Table Implementation
    [] Sorted Maps
        [] Sorted Search Tables
        [] Two Applications of Sorted Maps
    [] Skip Lists
        [] Search and Update Operations in a Skip List
        [] Probabilistic Analysis of Skip Lists
    [] Sets, Multisets, and Multimaps
        [] The Set ADT
        [] Python’s MutableSet Abstract Base Class
        [] Implementing Sets, Multisets, and Multimaps
    [] Exercises
---

## [] 11.Search Tree

    [] Binary Search Trees
        [] Navigating a Binary Search Tree
        [] Searches
        [] Insertions and Deletions
        [] Python Implementation
        [] Performance of a Binary Search Tree
    [] Balanced Search Trees
        [] Python Framework for Balancing Search Trees
    [] AVL Trees
        [] Update Operations
        [] Python Implementation
    [] Splay Trees
        [] Splaying
        [] When to Splay
        [] Python Implementation
        [] Amortized Analysis of Splaying
    [] (2,4) Trees
        [] Multiway Search Trees
        [] (2,4)-Tree Operations
    [] Red-Black Trees
        [] Red-Black Tree Operations
        [] Python Implementation
    [] Exercises
---

## [] 12.Sorting and Selection

    [] Why Study Sorting Algorithms?
    [] Merge-Sort
        [] Divide-and-Conquer
        [] Array-Based Implementation of Merge-Sort
        [] The Running Time of Merge-Sort
        [] Merge-Sort and Recurrence Equations
        [] Alternative Implementations of Merge-Sort
    [] Quick-Sort
        [] Randomized Quick-Sort
        [] Additional Optimizations for Quick-Sort
    [] Studying Sorting through an Algorithmic Lens
        [] Lower Bound for Sorting
        [] Linear-Time Sorting: Bucket-Sort and Radix-Sor
    [] Comparing Sorting Algorithms
    [] Python’s Built-In Sorting Functions
        [] Sorting According to a Key Function
    [] Selection
        [] Prune-and-Search
        [] Randomized Quick-Select
        [] Analyzing Randomized Quick-Select
    [] Exercises
---

## [] 13.Text Processing

    [] Abundance of Digitized Text
        [] Notations for Strings and the Python str Class
    [] Pattern-Matching Algorithms
        [] Brute Force
        [] The Boyer-Moore Algorithm
        [] The Knuth-Morris-Pratt Algorithm
    [] Dynamic Programming
        [] Matrix Chain-Product
        [] DNA and Text Sequence Alignment
    [] Text Compression and the Greedy Method
        [] The Huffman Coding Algorithm
        [] The Greedy Method
    [] Tries
        [] Standard Tries
        [] Compressed Tries
        [] Suffix Tries
        [] Search Engine Indexing
    [] Exercises
---

## [] 14.Graph Algorithm

    [] Graphs
        [] The Graph ADT
    [] Data Structures for Graphs
        [] Edge List Structure
        [] Adjacency List Structure
        [] Adjacency Map Structure
        [] Adjacency Matrix Structure
        [] Python Implementation
    [] Graph Traversals
        [] Depth-First Search
        [] DFS Implementation and Extensions
        [] Breadth-First Search
